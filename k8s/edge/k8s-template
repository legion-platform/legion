#!/usr/bin/env python3
#
#    Copyright 2017 EPAM Systems
#
#    Licensed under the Apache License, Version 2.0 (the "License");
#    you may not use this file except in compliance with the License.
#    You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS,
#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#    See the License for the specific language governing permissions and
#    limitations under the License.
#

"""
k8s-template application is a replacement of consul-template app.
It can generate config files based on K8s API response and execute a reload command.
"""

import sys
import os
import argparse
import logging
import time
from jinja2 import Environment, FileSystemLoader
from kubernetes import client, config, watch
import urllib3
import urllib3.exceptions

ROOT_LOGGER = logging.getLogger()


def build_client():
    """
    Configure and returns kubernetes client

    :return: :py:module:`kubernetes.client`
    """
    try:
        config.load_incluster_config()
    except config.config_exception.ConfigException:
        config.load_kube_config()

    # Disable SSL warning for self-signed certificates
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    return client.ApiClient()


def render_template(all_services, template_path, output_file_path, command=''):
    """
    Render a template with passed list of services into output file.

    :param all_services: a list of services
    :rtype all_services: list[V1Service]
    :param template_path: template file path
    :rtype template_path: str
    :param output_file_path: output file path
    :rtype output_file_path: str
    :param command: a command line which is executed after rendering
    :rtype command: str
    :return: None
    """

    # Configuring Environment for template
    j2_env = Environment(
        loader=FileSystemLoader([os.getcwd(), os.path.dirname(os.path.abspath(__file__))])
    )
    with open(output_file_path, 'w') as output_file:
        logging.debug('Output file path: %s' % output_file.name)
        # Reloading template on each iteration, in case it's changed
        template = j2_env.get_template(template_path)
        output_file.write(template.render({'services': all_services}))

    if command:
        os.system(args.command)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='K8S Template Renderer')
    parser.add_argument('--verbose', "-v", help='verbose log output',
                        action='store_true')

    parser.add_argument('--template', '-t', type=str, help='Template file path', required=True)
    parser.add_argument('--output', '-o', type=str, help='Output file path', required=True)
    parser.add_argument('--command', '-c', type=str, default='',
                        help='Command to reload configuration', required=False)
    parser.add_argument('--once', '-n', action='store_true',
                        help='Render template Once', required=False)
    parser.add_argument('--required-label', '-p', help='Pause length, in seconds', type=str,
                        default='', required=False)

    # --------- END OF SECTIONS -----------
    args = parser.parse_args(sys.argv[1:])

    if args.verbose or os.getenv('VERBOSE', ''):
        log_level = logging.DEBUG
    else:
        log_level = logging.ERROR

    ROOT_LOGGER.setLevel(log_level)

    # Reading Namespace from env.vars.
    namespace = os.environ.get('NAMESPACE', '')
    if not namespace:
        raise ValueError("NAMESPACE wasn't found in env var.")

    # Creating Kubernetes client
    core_api = client.CoreV1Api(build_client())

    # Reading a list of all services
    all_services_items = core_api.list_namespaced_service(namespace).items
    all_services = { service.metadata.name: service for service in all_services_items}
    render_template(all_services.values(), args.template, args.output, args.command)

    if not args.once:
        while True:
            try:
                w = watch.Watch()
                for event in w.stream(core_api.list_namespaced_service, namespace, _request_timeout=60):
                    service = event['object']
                    event_type = event['type']
                    if not args.required_label or args.required_label in service.metadata.labels:
                        service_name = service.metadata.name
                        if event['type'] == 'ADDED' or event['type'] == 'MODIFIED':
                            all_services[service.metadata.name] = service
                        elif event['type'] == 'DELETED' and service_name in all_services:
                            del all_services[service_name]
                        render_template(all_services.values(), args.template, args.output, args.command)
            except urllib3.exceptions.ReadTimeoutError:
                logging.debug('Caught ReadTimeoutError')
                continue
